/*

Desc: Global Health File that manages health, damage, and healing and death of both enemies and player
How to use:
    1. Attach to player and enemy of choice
    2. Use .GetComponent<Health> to access the functions and individual health of object/prefab the script is attached to
*/

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using Random=UnityEngine.Random;

public class Health : MonoBehaviour
{

    //Private Variables
    [SerializeField] private int health = 100; //current health of the object/prefab the files is attached to
    private int MAX_HEALTH = 100; //The max health of player (we cap it so that healing only works upto a certain number)

    public static Action OnPlayerDeath;
    public static Action OnEnemyDeath;

    public GameObject lowXP;
    public GameObject highXP;
    public GameObject medXP;
    //Sets Max health and current health to the object
    public void SetHealth(int maxHealth, int health)
    {
        this.MAX_HEALTH = maxHealth;
        this.health = health;
    }

    // Added for Visual Indicators
    private IEnumerator VisualIndicator(Color color)
    {
        GetComponent<SpriteRenderer>().color = color;
        yield return new WaitForSeconds(0.15f);
        GetComponent<SpriteRenderer>().color = Color.white;
    }

    //Manages Damage
    public void Damage(int amount)
    {
        if(amount < 0) { throw new System.ArgumentOutOfRangeException("Cannot have negative Damage"); } //base case

        this.health -= amount; //reduce health
        StartCoroutine(VisualIndicator(Color.red)); // Added for Visual Indicators

        if (health <= 0) { Die(); }
    }

    //Healing:
    //Use this function when a particular ability adds healing to the object
    public void Heal(int amount)
    {
        if (amount < 0) { throw new System.ArgumentOutOfRangeException("Cannot have negative healing"); } //base case

        bool wouldBeOverMaxHealth = health + amount > MAX_HEALTH;
        StartCoroutine(VisualIndicator(Color.green)); // Added for Visual Indicators

        if (wouldBeOverMaxHealth)
        {
            this.health = MAX_HEALTH;
        }
        else
        {
            this.health += amount;
        }
    }

    //Die Function
    private void Die()
    {

        if (this.CompareTag("Player"))
        {
            Time.timeScale = 0;
            OnPlayerDeath?.Invoke();
        }
        else
        {
            Vector3 enemyPos = gameObject.transform.position;
            OnEnemyDeath?.Invoke();
            if(this.CompareTag("Trojan")){
              this.gameObject.GetComponent<TrojanBoss>().dead = true;
            }else{
              this.gameObject.GetComponent<Enemy>().dead = true;
            }
            int r = Random.Range(0,100);
            if(r < 10){
              Instantiate(lowXP, enemyPos, Quaternion.identity);
            }else if(r < 15){
              Instantiate(medXP, enemyPos, Quaternion.identity);
            }else if(r < 19){
              Instantiate(highXP, enemyPos, Quaternion.identity);
            }
        }

        Destroy(gameObject);
    }
}
